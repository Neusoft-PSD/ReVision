function [gradIm, ddIm, linePoints] = stegerLines(im, sigma, minStrength)
% [edgelIm nrmIm dirIm] = stegerLines(IM, SIGMA, MINSTRENGTH)
%
% Compute the Steger lines.
%
% PARAMS:  
%  IM the 2D gray level input image
%  SIGMA (optional, default = 1.0) the std dev of the Gaussian filter.
%  MINSTRENGTH (optional, default = 1.0)  The threshold
%    value for the minimum gradient magnitude.  
%
% OUTPUT:  
%  edgelIm  binary image marking edgel locations.
%  nrmGradIm  image of norm of gradient image (NOT thresholded)
%  dirIm    direction of gradient image (in terms of theta/pi), so
%           directions are periodic in the interval (0, 2]. 
%           dirIm is NaN at pixels for which nrmGradIm < minStrength.  

% ADJ 9/01.

%%%%%%%%%%%%%%% Check parameters  %%%%%%%%%%%%%%%%%%%%%%%

%%% Fill in default parameter values, and correct bogus parameter values.
if ~exist('sigma', 'var')  %% sigma is the std dev for the Gaussian filters
  sigma = 1.0;
elseif (sigma < 0.5/3)
  fprintf(2, 'User specified sigma = %e is too small.\n', sigma); 
  sigma = 0.5000001/3;
  fprintf(2, 'Using sigma = %f instead\n', sigma);
end

if ~exist('minStrength', 'var')  
  minStrength = 1; 
elseif minStrength<=0.0
  fprintf(2,'Invalid edge strength tolerance %e\n', minStrength); 
  minStrength = eps;
  fprintf(2,'Using edge strength tolerance = %e\n', minStrength);
end

%%%%%%%%%%%%%%% Build Filter Kernels %%%%%%%%%%%%%%%%%%%%%%%

%%% Build Gaussian filter masks, along with derivatives.
%%% The second derivative is not used yet.
sigmaSqr = sigma*sigma;
gFiltSize = 2 * round(3.0 * sigma) + 1;
x = [1:gFiltSize] - round((gFiltSize+1)/2);
gFilt = exp(- x .* x / (2.0*sigmaSqr));
gFilt = gFilt/ sum(gFilt(:));
gxFilt = - (x / sigmaSqr) .* gFilt;
gxxFilt = ((x / sigmaSqr).^2 - 1.0/sigmaSqr) .* gFilt;

%%%%%%%%%%%%%%% Do separable convolutions %%%%%%%%%%%%%%%%%%%

gradIm = zeros([size(im), 2]);
gradIm(:,:,1) = rconv2sep(im, gxFilt, 1);
gradIm(:,:,2) = rconv2sep(im, 1, gxFilt);

ddIm = zeros([size(im),3]);
% dx^2
ddIm(:,:,1) = rconv2sep(im, gxFilt, 1);
ddIm(:,:,1) = rconv2sep(ddIm(:,:,1), gxFilt, 1);

% dy^2
ddIm(:,:,2) = rconv2sep(im, 1, gxFilt);
ddIm(:,:,2) = rconv2sep(ddIm(:,:,2), 1, gxFilt);

% dxdy
ddIm(:,:,3) = rconv2sep(im, gxFilt, 1);
ddIm(:,:,3) = rconv2sep(ddIm(:,:,3),1,gxFilt);

%%%%%%%%%%%%%%% Gradient Magnitude Image %%%%%%%%%%%%%%%%%%%
 
nrmGradIm = sum(gradIm .* gradIm, 3).^0.5;

%%%%%%%%%%% Compute the directions
dirIm = zeros(size(im));
enoughGradAmp = (nrmGradIm >= minStrength);

dxIm = gradIm(:,:,1);
dyIm = gradIm(:,:,2);
dirIm(enoughGradAmp) = atan2(dyIm(enoughGradAmp), dxIm(enoughGradAmp))/pi;
%%% This value is periodic in [-1, 1].
% Branch cut at 0 degrees (edges look like "dark | bright")
cut = 0;
while (sum(sum(dirIm > cut+2.0)) > 0)
  dirIm(dirIm>cut+2.0) = dirIm(dirIm>cut+2.0) - 2.0;
end
while (sum(sum(dirIm <= cut)) > 0)
  dirIm(dirIm<=cut) = dirIm(dirIm<=cut) + 2.0;
end
%%% dirIm now in the range (0, 2.0]
dirIm(~enoughGradAmp) = NaN;

%%%%% Compute normal image
nx = cos(dirIm*pi);
ny = cos(dirIm*pi);

%%%%% t-matrix
tnum = (gradIm(:,:,1).*nx + gradIm(:,:,2).*ny);
t = -tnum ./ ...
    (ddIm(:,:,1).*nx.^2+2*ddIm(:,:,3).*nx.*ny+ddIm(:,:,2).*ny.^2);

px = t.*nx;
py = t.*ny;

pxhalfIm = zeros(size(px));
pxhalfIm(find(px > -0.5 & px < 0.5)) = 1;

pyhalfIm = zeros(size(py));
pyhalfIm(find(py > -0.5 & py < 0.5)) = 1;

linePoints = pxhalfIm & pyhalfIm;
